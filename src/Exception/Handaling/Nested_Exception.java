package Exception.Handaling;

//        The program works as follows. When you execute the program with no command-line arguments,
//        a divide-byzero exception is generated by the outer try block. Execution of the program with one
//        command-line argument generates a divide-by-zero exception from within the nested try
//        block. Since the inner block does not catch this exception, it is passed on to the outer try
//        block, where it is handled. If you execute the program with two command-line arguments,
//        array boundary exception is generated from within the inner try block. Here are sample
//        runs that illustrate each case
//                C:\>java NestTry
//                Divide by 0: java.lang.ArithmeticException: / by zero
//                C:\>java NestTry One
//                a = 1
//                Divide by 0: java.lang.ArithmeticException: / by zero
//                C:\>java NestTry One Two
//                a = 2
//                Array index out-of-bounds:
//                java.lang.ArrayIndexOutOfBoundsException:42

import java.util.Random;

class NestedTry {
    // these two method will work same as main method of Nested_exception
    static void nestedTry(int a) {
        try {
            if(a == 1) a = a / (a-a);   //divide by zero // this will detect by catch block parentMethod() catch
            if(a == 2) {
                int c[] = { 1 };
                c[45] = 10;
            }
        }
        catch(ArrayIndexOutOfBoundsException e) {
            System.out.println(e);;
        }
    }
    void parentMethod() {
        try {
            Random r = new Random();
            int a = r.nextInt();

            int b = 44 / a;
            System.out.println("a: " + a);

            nestedTry(a); //
        }
        catch (ArithmeticException e) {
            System.out.println(e);
        }
    }
}
public class Nested_Exception {
    public static void main(String[] args) {
        try {
            int a = args.length;

//            int b = 44 / a;
            System.out.println("a: " + a);

            try {
                if(a == 0) {
                    System.out.println("inside nested try");
                    int b = 20 / a;
                }
                if(a == 1) a = a / (a-a);   //divide by zero // this will detect by outer catch block of parent try block
                if(a == 2) {
                    int c[] = { 1 };
                    c[45] = 10;
                }
            }
            catch(ArrayIndexOutOfBoundsException e) {
                System.out.println(e);;
            }

            // this line will be skipped because previously an exception caught
            System.out.println("After nested try block");
        }
        catch (ArithmeticException e) {
            System.out.println(e);
        }

    }
}


//        The try statement can be nested. That is, a try statement can be inside the block of another
//        try. Each time a try statement is entered, the context of that exception is pushed on the
//        stack. If an inner try statement does not have a catch handler for a particular exception,
//        the stack is unwound and the next try statementâ€™s catch handlers are inspected for a match.
//        This continues until one of the catch statements succeeds, or until all of the nested try
//        statements are exhausted. If no catch statement matches, then the Java run-time system
//        will handle the exception.